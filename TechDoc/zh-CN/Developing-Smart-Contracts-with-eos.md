# 开发智能的合同/分散的应用与EOS。IO使用eos开发智能合约（分布式应用程序）

> 本文翻译自：https://eosio.github.io/eos/md_contracts_eoslib_tutorial.html
> 
> 译者：[区块链中文字幕组胡亮](https://github.com/gumoon)
> 
> 翻译时间：2017-09-20

该教程是针对那些想要开始建立的分散式应用程序或智能的合同使用EOS。IO软件开发工具包。 它将涵盖书面合同/应用C++和上传他们的块链的。 它将不包括如何建造或部署互动网络界面。

本教程的目标用户：想使用eos sdk来构建分布式应用程序或智能合约的人。包括两部分内容：如何使用C++语言编写智能合约以及上传智能合约到区块链。它不涉及怎么编译eos和部署交互式web接口。

对其余的这一教程中，我们将使用术语"合同"来指代权力分散的应用。

在后面的文章中，我们将使用术语"合同"表示分布式应用程序。

## 所需要的背景知识需要的背景知识

这个教程假定你有基本了解如何使用'eosd'和'eosc'建立一个节点和部署的例子合同。 如果你有尚未成功之后，教程，然后做第一次回来。

本教程假定你已经基本知道如何使用`eosd`和`eosc`来搭建一个节点和部署例子合约。如果你没有按照那个教程做成功，请先去完成它，然后再回来这里。

### C/C++经验要求需要有C/C++编程经验

EOS。IO基于"区块链"执行用户产生的应用程序和代码使用网络会(WASM). WASM是一个新兴的网络标准与广泛的支持谷歌、微软、苹果、以及其他人。 目前最为成熟的工具，用于建筑应用程序汇编，以WASM是铛/编程与他们C/C++编译器。

EOS。IO底层区块链使用WASM执行用户应用程序。WASM是一个正被谷歌、用、苹果和其他公司广泛支持的web标准。当前构建应用程序最成熟的工具链是：使用带有c/c++编译器的铛/llvm来编译应用程序为WASM。

其他工具链的发展通过的第3次缔约方包括：生锈，蟒蛇，并Solidiity的。 虽然这些其他语言可能会出现更为简单，他们的表现可能会影响的应用规模的可以构建。 我们希望，C++将是最好的语言，用于发展高效和安全的智能的联系人。

第三方的其他工具链包括：锈，蟒蛇，和Solidiity。这些语言看起来更简单的性能可能会影响到应用程序的扩展。的，C++是最好的用于开发高性能、安全智能合约的编程语言。

如果你不是经验丰富的与C/C++，然后你应该学习基础知识，然后再回来。

如果你对C/C++不熟，你应该先去学习一下C++基础知识，然后再回来这里。

### Linux/Mac OS X命令行Linux。Mac OS x命令行

EOS的。IO软件只有正式支持unix环境和建筑铿锵。

EOS。IO以，官方仅支持Unix。中。铛来构建。

## 基本的明智的合同/分散的应用智能合约/分布式应用程序基础

从根本上每一个合同是一个国家机，响应签署了用户的行动。 这些合同是上载到区块链作为预先编制的网组件(WASM)的文件ABI(应用程序接口)。

的每一个智能合约都是一个状态机。它响应签名的用户行为。智能合约以WASM和ABI的形式被上传到区块链。

让事情变简单的我们已经创建了一个工具，称为eoscpp，它可被用来引导一个新的合同。 这个工作我们假设你已经安装的eosio/eos码的安装和${CMAKE_INSTALL_PREFIX}/bin是在你的路径。

的我们已经创建了`eoscpp`工具来生成一个新的智能合约。该工具正常工作的前提是，你已经安装了eosio/eos代码，并且`${CMAKE_INSTALL_PREFIX}/bin`在你的`PATH`路径了。

> 译者说： `eoscpp`工具在你使完eos项目之后。`/path/to/建立/tools`文件夹中。你需要执行`make install`来安装它。

    $eoscpp-n你好
    $cd你好
    $ls
    

上述将创建一个新的空项目中的'/日。hello'的文件夹，带三个文件：

以上命令执行完后，将`/日。hello`目录下生成一个新的空项目。`hello`文件夹包括三个文件：

    你好。阿比你好。hpp hello.cpp
    

让我们看一下最简单的可能的合同：

让我们来看一下最简单可用的智能合约：

    猫hello.cpp
    #包括<hello.hpp>
    /**
    *Init()以及申请()方法必须C呼吁《公约》这样的区块链可以查找和
    *呼吁这些方法。
     */
    外部"C"{
    /**
    *这种方法被称为一旦合同时发布或更新。
         */
    void init(){
    eos::print("Init世界！\n");
    }
    ///应用方法实现了派遣的事件的这个合同
    无效的适用(uint64_t码，uint64_t行动){
    eos::print("Hello World:"eos:：姓名(码)，"->"eos:：姓名(行动),"\n");
    }
    }//外部的"C"
    

这种合同实现了两个入境点，初始和适用。 它所做的是记录传递的信息，并使得没有任何其他检查。 任何人都可以提供任何消息随时提供的框生产者允许它。 不存在任何需要签名的，合同将支付的带宽的消耗。

这个合约实现两个入口点：init和适用。他们都仅仅是打印了日志，而没有做其他的校验。所任何人都可以在任何时间发生任何消息，只要区块生产者允许。不带任何签名的合约将会产生带宽消费的账单。

你可以编制这份合同文本版本的WASM(中。废)，像这样：

你可以像这样编译合约为文本格式的WASM：

    $eoscpp-o你好。废hello.cpp
    

### 部署合同部署合约

现在你已经编制了你的应用程序时进行部署。 这将要求你做到如下第一:

既然你已经编译完了，下面就来部署它。部署之前，需要先完成以下步骤：

1. 开始eosd带钱包插件启用带着钱包插件启动`eosd` 
2. 创建一个钱包&进键用于至少一个帐户创建一个钱包，并且为至少一个账户导入私钥
3. 保持你的钱包锁确保钱包没有锁定

假设你的钱包是解锁和有钥匙${account}，你现在可以上传这个合同的区块链的下列命令：

假设你的钱包没有锁定的。${account}账户的key，你可以使用以下命令上传合约到区块链：

    $eosc设置合同${account}你好。伙你好。abi
    阅读伙...
    组装WASM...
    出版合同...
    {
    "返回有关数据库级事务的信息":"1abb46f1b69feb9a88dbff881ea421fd4f39914df769ae09f66bd684436443d5",
    "处理":{
    "refBlockNum":144,
    "refBlockPrefix":2192682225,
    "过期":"2017-09-14T05:39:15",
    "范围"的：[
    "eos",
    "${account}"
    的]
    "签名的"：[
    "2064610856c773423d239a388d22cd30b7ba98f6a9fbabfa621e42cec5dd03c3b87afdcbd68a3a82df020b78126366227674dfbdd33de7d488f2d010ada914b438"
    的]
    "信息":[{
    "代码":"eos",
    "类型"："setcode",
    "授权":[{
    "帐户":"${account}",
    "权限":"活动"
    }
    的]
    "数据"："0000000080c758410000f1010061736d0100000001110460017f0060017e0060000060027e7e00021b0203656e76067072696e746e000103656e76067072696e7473000003030202030404017000000503010001071903066d656d6f7279020004696e69740002056170706c7900030a20020600411010010b17004120100120001000413010012001100041c00010010b0b3f050041040b04504000000041100b0d496e697420576f726c64210a000041200b0e48656c6c6f20576f726c643a20000041300b032d3e000041c0000b020a000029046e616d6504067072696e746e0100067072696e7473010004696e697400056170706c790201300131010b4163636f756e744e616d65044e616d6502087472616e7366657200030466726f6d0b4163636f756e744e616d6502746f0b4163636f756e744e616d6506616d6f756e740655496e743634076163636f756e740002076163636f756e74044e616d650762616c616e63650655496e74363401000000b298e982a4087472616e736665720100000080bafac6080369363401076163636f756e7400076163636f756e74"
    }
    的]
    "输出":[{
    "通知":[],
    "deferred_transactions":[]
    }
    ]
    }
    }
    

如果你正在监测输出eosd过程中，你应该看到：

如果你正在监控`eosd`输，你应该能看到：

    ...]initt产生的框#188249@2017-09-13T22:00:24 0trxs0待
    Init世界！
    Init世界！
    Init世界！
    

你会发现线"Init的世界！"执行3次，这不是一个错误。 当块链是处理交易以下情况：

你已经注意到了"Init的世界！" 被执行了3次，这不是错误。区块链处理交易的流程是这样的：

1. eosd收到新的交易eosd收到一个新的交易 
    - 创建一个临时会议创建一个临时会话
    - 尝试应用事务尝试去适用这个交易
    - 成功和打印"Init的世界！" 成功的话并且打印："Init的世界！"
    - 或未能撤消的变化(可能无法在印刷之后"Init World!") 失败的话，撤销改动
2. eosd开始产生一个框eosd开始生产一个区块 
    - 撤消所有未决状态撤销所有未决状态
    - 推动所有交易，因为它建立的框把所有的交易推送过来生产区块
    - 印"Init的世界！"第二次第二次打印"Init的世界！"
    - 完成的建筑的框完成区块生产
    - 撤消所有临时更改，同时创造框撤销生产区块时的所有临时改变
3. eosd推动生成方块，如果它收到网络eosd推送生成的区块到区块链网络 
    - 印"Init的世界！"第三次第三次打印"Init世界"

在这一点上你的合同是准备好要开始接收信息。 由于默认的消息处理程序接受所有消息我们可以把它送任何我们想要的。 让我们试试把它发送一个空的信息：

在你的合约准备好开始接受消息了。因为默认的消息处理器接收任意的消息的我们可以发送我们想发送的任何消息。我们来尝试发送一个空消息。

    $eosc推消息${account}hello'"abcd"'--范围${account}
    

这种命令将消息发送"你好"的二进制数据表示hex string"abcd"的。 请注意，在一个比我们将展示如何定义的阿比让你可以替代hex string一个漂亮的、易于阅读，JSON对象。 现在我们仅仅是要表明如何消息类型的"你好"被派往来帐户。

这个命令将发送以十六进制字符串"abcd"表示的二进制数据为消息内容的消息"你好"。以现在我们将展示如何定义ABI，以便你可以使用一个美观的，易读的JSON对象来替换十六进制字符串。在我们只不过想举例说明的"你好"类型的消息是如何被分发给某个账号的。

结果是：

的：

    {
    "返回有关数据库级事务的信息":"69d66204ebeeee68c91efef6f8a7f229c22f47bcccd70459e0be833a303956bb",
    "处理":{
    "refBlockNum":57477,
    "refBlockPrefix":1051897037,
    "过期":"2017-09-13T22:17:04",
    "范围"的：[
    "${account}"
    的]
    "签名":[],
    "信息":[{
    "代码":"${account}",
    "类型"："你好"，
    "授权":[],
    "数据":"abcd"
    }
    的]
    "输出":[{
    "通知":[],
    "deferred_transactions":[]
    }
    ]
    }
    }
    

如果你是以下沿着在eosd然后你应该看看下面滚动屏幕上：

如果你正盯着`eosd`输，你应该已经看到下面的内容滚动在屏幕上。

    你好世界：${account}->hello
    你好世界：${account}->hello
    你好世界：${account}->hello
    

再一次的你的合同执行和撤销两次前正在应用的第3次作的一部分产生块。

再一次看到，合约被执行和撤销了两次，第三次作为一个生成的区块被应用。

### 消息名称的限制消息名约束

消息的类型(例如。 "hello")是实际上base32编码64位整数。 这意味着它们是有限的，a-z、1-5和'.'的第12，和如果有一个第13字然后它仅限于第16字('.'和一个-p)。

消息（像："你好"）实际上是经base32算法编码的64位整数。在消息名开头的12个字符被限制为:字符a-z,1-5和'.'。超过13个字符则消息名开头的16个字符限制为：'.'和一个p。

### ABI-应用程序接口应用程序二进制接口

ABI是一个星说明如何转换用户操作它们之间的JSON和二元表示。 ABI还描述了如何转换的数据库的国家/从手机中。 一旦你已经说明你的合同通过一个ABI然后开发者和用户将能够进行交互与合同无缝通过手机中。

ABI是基于JSON格式来描述在JSON格式与二进制格式之间怎么转换用户动作。ABI也描述怎么让数据库状态和JSON格式互转。一旦你通过ABI来描述你的合约，其他开发者和用户将能够通过JSON跟你的合约进行交互。

我们正在努力工具，将自动生成的ABI从C++的源代码，但是目前你可能已经产生。

我们的工具将从C++源码自动生成ABI。中某些时候你可能不得不手动生成它。

这里是一个例子是骨架合同ABI看起来像:

这是一个骨架合约ABI的例子，看起来像这样：

    {
    "类型":[{
    "newTypeName":"帐户名"的，
    "类型"："Name"
    }
    的]
    "结构":[{
    "名称"："转移"，
    "基地":"",
    "fields":{
    "从":"帐户名"的，
    "到":"帐户名"的，
    "量":"UInt64"
    }
    },{
    "名称"："账户"，
    "基地":"",
    "fields":{
    "帐户":"名称"，
    "平衡":"UInt64"
    }
    }
    的]
    "行动":[{
    "行动":"转移"，
    "类型"："转移"
    }
    的]
    "表"的：[{
    "表"的："账户"，
    "类型"："账户"，
    "时间":"i64",
    "keynames":["帐户"],
    "keytypes":["Name"]
    }
    ]
    }
    

你会注意到，这ABI定了一项行动转移类型的转让。 这告诉EOS。IO当${account}->传递消息是看到，有效负荷类型的转让。 该类型的转让定义在结构列在对象的有名称的设定"转让"。

你肯定注意到这个ABI定义了一个转移所转让行。它告诉EOS。IO，当向账户发送传递消息，消息体为传输类型。传类型定义在对象的结构体数组中，名字叫转移。

    ...
    "结构":[{
    "名称"："转移"，
    "基地":"",
    "fields":{
    "从":"帐户名"的，
    "到":"帐户名"的，
    "量":"UInt64"
    }
    },{
    ...
    

它有几个领域，包括从，并金额。 这些领域有着相应的类型帐户名，帐户名和UInt64的。 帐户名被定义为一个typedef的类型阵列的名字，这是一个内置的类型使用的编码一个uint64_t为base32(例如：帐户名称)。

它包括几个字段：从，和数量。这些字段对应的类型为：帐户名，帐户名和UInt64。帐户名类型是类型数组中名类型的别名。名类型是一个內建类型，用base32算法编码一个uint64_t类型值。（如：账户名）

    {
    "类型":[{
    "newTypeName":"帐户名"的，
    "类型"："Name"
    }
    的]
    ...
    

现在，我们已经审查了ABI定义的骨架，我们可以构建一个消息呼吁转让：

既然我们已经看过了骨架中ABI的定义，现在我们来构造一个传消息调用。

    eosc推消息${account}转让'{"从":"货币"，"到":"inita的"、"数量":50}'--范围initc
    2570494ms线-0主。cpp:797操作员()]转换参数，以二进制...
    {
    "返回有关数据库级事务的信息":"b191eb8bff3002757839f204ffc310f1bfe5ba1872a64dda3fc42bfc2c8ed688",
    "处理":{
    "refBlockNum":253,
    "refBlockPrefix":3297765944,
    "过期":"2017-09-14T00:44:28",
    "范围"的：[
    "initc"
    的]
    "签名":[],
    "信息":[{
    "代码":"initc",
    "类型"："转移"，
    "授权":[],
    "数据":{
    "从":"货币"，
    "到":"inita",
    "量":50
    },
    "hex_data":"00000079b822651d000000008040934b3200000000000000"
    }
    的]
    "输出":[{
    "通知":[],
    "deferred_transactions":[]
    }
    ]
    }
    }
    

如果你观察的输出eosd你应该看到：

如果你观察eosd输，你应该看到了：

    你好世界：${account}->transfer
    你好世界：${account}->transfer
    你好世界：${account}->transfer
    

## 处理参数的传递消息的处理转让消息参数

根据ABI的传递消息的格式：

根据《中，转让消息的格式：

    "fields":{
    "从":"帐户名"的，
    "到":"帐户名"的，
    "量":"UInt64"
    }
    

我们也知道，帐户名->的名字->UInt64这意味着二进制代表的信息是相同的：

上`AccountName->Name->UInt64`，这个转换意味着，消息的二进制格式跟下面的表示一样：

    结构转{
    uint64_t；
    uint64_t；
    uint64_t量；
    };
    

EOS的。IO C API提供消息的有效载荷通过的消息API:

EOS。IO接口提供消息API来访问消息体内容。

    uint32_t messageSize();
    uint32_t readMessage(void*msg，uint32_t内);
    

让我们修改hello.cpp 打印出来的内容的信息：

我们来修改`hello的。cpp`，打印消息体的内容：

    #包括<hello.hpp>
    外部"C"{
    void init(){
    eos::print("Init世界！\n");
    }
    结构转{
    uint64_t；
    uint64_t；
    uint64_t量；
    };
    无效的适用(uint64_t码，uint64_t行动){
    eos::print("Hello World:"eos:：姓名(码)，"->"eos:：姓名(行动),"\n");
    如果(action==N(转让)){
    传送消息；
    static_assert(sizeof(消息)==3*sizeof(uint64_t),"意想不到的填充");
    自动读取=readMessage(&message,sizeof(消息));
    assert(read==sizeof(消息)，"消息太短");
    eos::print("转移"的信息。数额，"来自"eos:：姓名(信息。从)中，"到"eos:：姓名(信息。到),"\n");
    }
    }
    }//外部的"C"
    

然后我们可以重新编译和部署：

接我们使用以下命令重新编译和部署该合约：

    eoscpp-o你好。废hello.cpp 
    eosc设置合同${account}你好。伙你好。abi
    

eosd会呼init()再次，因为重新部署

因为重新部署，eosd将再次调用`init()`

    Init世界！
    Init世界！
    Init世界！
    

然后我们就可以执行转让：

中我们执行转移的行为：

    $eosc推消息${account}转让'{"从":"货币"，"到":"inita的"、"数量":50}'--范围${account}
    {
    "返回有关数据库级事务的信息":"a777539b7d5f752fb40e6f2d019b65b5401be8bf91c8036440661506875ba1c0",
    "处理":{
    "refBlockNum":20,
    "refBlockPrefix":463381070,
    "过期":"2017-09-14T01:05:49",
    "范围"的：[
    "${account}"
    的]
    "签名":[],
    "信息":[{
    "代码":"${account}",
    "类型"："转移"，
    "授权":[],
    "数据":{
    "从":"货币"，
    "到":"inita",
    "量":50
    },
    "hex_data":"00000079b822651d000000008040934b3200000000000000"
    }
    的]
    "输出":[{
    "通知":[],
    "deferred_transactions":[]
    }
    ]
    }
    }
    

和eosd我们应该看到以下产出：

在eosd中，我们应该能看到以下输出：

    你好世界：${account}->transfer
    转移50从货币inita
    你好世界：${account}->transfer
    转移50从货币inita
    你好世界：${account}->transfer
    转移50从货币inita
    

### 使用C++API阅读邮件的使用C++API来读消息

迄今为止我们使用的C API，因为它是最低的水平API，直接暴露的EOS。IO到WASM虚拟机。 幸运的是，eoslib提供了一个更高的水平API，消除许多锅炉板。

供的我们已经使用C语言接口实现了读消息。C语言接口是EOS。IO暴露给WASM虚拟机的最低级别接口。的`eoslib`提供更高级别的接口，来帮助我们屏蔽很多底层细节。

    namespace eos{
    template<typename T>
    T currentMessage();
    }
    

我们可以更新hello.cpp 可以更加简明如下：

我们可以像下面这样来更新`hello的。cpp`，`hello的。cpp`文件变得更加简洁了。

    #包括<hello.hpp>
    外部"C"{
    void init(){
    eos::print("Init世界！\n");
    }
    结构转{
    eos::名称；
    eos::名称；
    uint64_t量；
    };
    无效的适用(uint64_t码，uint64_t行动){
    eos::print("Hello World:"eos:：姓名(码)，"->"eos:：姓名(行动),"\n");
    如果(action==N(转让)){
    自动信息=eos::currentMessage<transfer>();
    eos::print("转移"的信息。数额，"从"的信息。从"到"，信息。来,"\n");
    }
    }
    }//外部的"C"
    

你会发现我们的更新的传输结构，以使用eos::名称直接输入，然后condenced的检查周围readMessage到一个单一的呼吁currentMessage的。

你肯定注意到，我们修改传结构为直接使用`eos::Name`类型。`readMessage`相关的代码替换为一次调用`currentMessage`。

后汇编和传你应该得到相同的结果C版本。

重新编译并且上传到区块链后，你应该看到跟C版本的代码相同的结果。

## 要求发件人的权力转移

一个最常见的要求的任何合同是确定是谁允许执行的行动。 在这种情况下的一个curency转让，我们希望要求的账户定义由从参数迹象的信息。

一个通用的合约需求是定义谁被允许执行某个行动。在金融交易的案例中，我们要求转出账户的消息带签名。

EOS的。IO软件将采取的强制执行和验证的签名，所有你需要做的是需要有必要的权威。

EOS。IO软件将强制验证签名。你只需要请求必要的授权。

    ...
    无效的适用(uint64_t码，uint64_t行动){
    eos::print("Hello World:"eos:：姓名(码)，"->"eos:：姓名(行动),"\n");
    如果(action==N(转让)){
    自动信息=eos::currentMessage<transfer>();
    eos::requireAuth(信息。从);
    eos::print("转移"的信息。数额，"从"的信息。从"到"，信息。来,"\n");
    }
    }
    ...
    

后建设和部署我们可以试图转移再次：

重新编译和部署后，我们再次尝试转让：

     eosc推消息${account}转让'{"从":"initb"，"到":"inita的"、"数量":50}'--范围${account}
    1881603ms线-0主。cpp:797操作员()]转换参数，以二进制...
     1881630ms线-0主。cpp:851主要]失败的错误：10assert_exception:主张的例外
    status_code==200:错误
    :3030001tx_missing_auth：缺少所需的权力
    交易是缺少所需的授权从initb
    {的"账户":"initb"}
    thread-0message_handling_contexts的。cpp:19require_authorization
    ...
    

如果你看上eosd你会看到这样的：

在eosd输出里，你会看到这些：

    你好世界：initc->transfer
    1881629ms线-0chain_api_plugin的。cpp:60操作员()]的例外时遇到处理链。push_transaction:
    ...
    

这表明，它企图用你的交易中，印刷的初始"Hello World"，然后中止时eos::requireAuth未能找到授权的账户initb的。

这显示区块链尝试去执行你的交易，打印了初始化"你好世界"的中调入`eos::requireAuth`时，因找不到initb账户的授权信息而失败中的交易中断了。

我们可以解决这个问题告诉eosc添加所需要的权限：

我们可以修复这个问题：后的权限参数来调用`eosc`。

    eosc推消息${account}转让'{"从":"initb"，"到":"inita的"、"数量":50}'--范围${account}--权限initb@活动
    

--权限命令定义的帐户和允许的水平，在这种情况下，我们使用的活动的机构，它是默认。

`--permission`命令选项定义了账户和权限级别。针对授权失败的情况，我们使用默认的活动的权限。

这次的转让应有的工作就像我们之前看到的。

在中转应该像之前那样正常执行。

## 中止的消息错误

大部分的合同的发展验证的先决条件，这样的转让金额大于0。 如果一个用户试图执行一种无效行动，那么合同必须中止及任何修改获得自动恢复。

合约开发的大部分工作是验证先决条件，如：转移的金额要大于0。如果用户尝试执行一个非法动作，合约必须中断并且自动回滚所有的更改。

    ...
    无效的适用(uint64_t码，uint64_t行动){
    eos::print("Hello World:"eos:：姓名(码)，"->"eos:：姓名(行动),"\n");
    如果(action==N(转让)){
    自动信息=eos::currentMessage<transfer>();
    assert(信息。量> 0，"必须转移金额超过0");
    eos::requireAuth(信息。从);
    eos::print("转移"的信息。数额，"从"的信息。从"到"，信息。来,"\n");
    }
    }
    ...
    

我们现在可以汇编、部署和试图执行一个转让0:

我们编译一，并且尝试执行一个转移金额为0的动作：

    $eoscpp-o你好。废hello.cpp
    $eosc设置合同${account}你好。伙你好。abi
    $eosc推消息${account}转让'{"从":"initb"，"到":"inita的"、"数量":0}'--范围initc--权限initb@活动
    3071182ms线-0主。cpp:851主要]失败的错误：10assert_exception:主张的例外
    status_code==200:错误
    :10assert_exception:主张的例外
    测试：断言是失败必须转移金额超过0