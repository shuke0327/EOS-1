> 原文链接：[https://eosio的。审查的。io/eos/组__contractdev的。html](https://eosio.github.io/eos/group__contractdev.html)
> 
> 的：区块链中文字幕组-[张奎](https://github.com/byzhangkui) [胡亮](https://github.com/gumoon)
> 
> 信：区块链中文字幕组-[梓岑](https://yoyow.org/)

# 如何写入合同EOS如何为EOS。IO编写智能合约

导言写入合同EOS。IO.

EOS。IO合约编写简介。

## 模块，模块

[数据库API](#)

Api存储和检索数据的区块链

在区块链上存储和检索数据的接口。

[数学API](#)

定义的共同学的功能。

定义常用数学函数。

[消息API](#)

定义API，用于查询信息的性质。

定义消息属性查询接口。

[控制台API](#)

使用登录/打印文本信息。

支持应用程序记录/打印文本消息。

[令牌API](#)

定义ABI用于与标准兼容的令牌的信息和数据库的数据表。

定义ABI（应用系统二进制接口），实现与标准兼容的令牌消息及数据库表之间的交互

[内置的类型](#)

指定typedef和别名。

指定类型定义和别名。

## 详细描图

### 背景背

EOS。IO合同(aka应用程序)部署到区块链作为预先编制的网会(又名WASM). WASM是编制从C/使用C++编程，并铛，这意味着你会需要的知识C/C++为了发展你的块链中的应用。 虽然这是可能的发展在C，我们强烈建议，所有开发人员使用的EOS。IO C++API其提供更强大的类型的安全和一般更易于阅读。

EOS。IO合约（序）以预编译的网组件（WASM）形式部署在区块链上。WASM使用C++编程，通过编程和铛编译中的许EOS。IO智能合约首先需要具备C/C++。。中虽然可以用C语言来开发，但我们强烈推荐使用C++口。C++接口是强类型安全性的，并且也更容易阅读。

### 应用程序结构应用程序结构

EOS。IO应用程序的设计围绕事件(又名信息)的处理，应对用户的行动。 例如，一个用户可能会转移标记的另一个用户。 这一事件可以被处理以及可能被拒绝通过发送、接收和货币应用程序本身。

EOS。IO应用程序是围绕响应用户行为的事件（息）处理来设计的。如用户间的代币转账交易会触发一个事件。这个事件可以被发送方，接收方或者当前应用程序本身进行处理或者拒绝。

作为一个应用程序开发者你能决定什么行动，用户可以采取和处理程序可以或必须在应对这些事件。

开发者需要决定用户可以触发哪些行为，以及哪些处理函数应该或者必须被调用，用以作为对这些事件的响应。

#### 入境点入口点

EOS。IO应用程序都有一个适用这样主要在传统的应用程序：

EOS。IO应用程序提供适用方法作为入口点，类似传统应用程序的主要方法：

```C
外部"C"{
void init();
无效的适用(uint64_t码，uint64_t行动);
}
```

主要是给出的参数码和行动，其唯一标识的每个事件的系统。 例如，代码可能是一个汇合同和行动可能会转移。 这个事件(代码，行动)可以通过几个合同包括发送者和接收者。 这是给你的应用程序，以弄清楚该怎么做为了应对这样的一个事件。

适用方法包含码和行动，这的在系统内通过这两个参数可唯一标识每个事件。以码可以是一个现金合约，而行动就是转移的行为。这个事件（代码的行动）可以被传递到包括发送者和接收者的多个合约中。如何响应一个事件,由应用程序确定。

init是另一个切入点就是所谓的一次后立即载入代码。 这是你应该进行一次初始化的状态。

init是另外一个程序入口点，在加载代码后会被立即调用，且只被调用一次的。在这里你可以实现一次性的状态初始化。

#### 例如申请入境的处理程序入口处理函数的示例

一般来说，你应该用你的入口处理程序，派遣事件的功能，实现大多数的逻辑和选择地拒绝的事件，合同无法或不愿意接受。

一你应该使用入口处理函数去分发事件到对应的方法。这些方法实现主要的处理逻辑，或者选择性地拒绝合约不识别或者不应该接受的事件。

```C
外部"C"{
无效的适用(uint64_t码，uint64_t行动){
如果(代码==N(货币)){
如果(action==N(转让))
货币：:apply_currency_transfer(currentMessage<货币：：传输>());
}else{
assert(假的，"拒绝的意外事件");
}
}
}
```

> **注意说明**
> 
> 当限定入境点，这是需要它们都放在一个外部"C"代码块，使用c++名mangling[^footnote]没有得到适用的功能。
> 
> 当你定义入口点时，需要将代码放在外部"C"代码块中，使用C++名字修饰<sup id="fnref2:footnote"><a href="#fn:footnote" class="footnote-ref">1</a></sup>不会应用到该方法上。

[^footnote]: *name mangling*名字修饰，又译做名字粉碎、名字重整，是编译器在函数、体、类或其它的数据类型的名字中编码附加信息一种方法，以消除二义性。应用场景如区分重载函数，标识调用约定等。[&#8617;](#fnref2:footnote){.footnote-backref}